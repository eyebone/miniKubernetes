// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: share.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_share_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_share_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_share_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_share_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_share_2eproto;
namespace share {
class ApplyDeploymentRequest;
struct ApplyDeploymentRequestDefaultTypeInternal;
extern ApplyDeploymentRequestDefaultTypeInternal _ApplyDeploymentRequest_default_instance_;
class ApplyPodRequest;
struct ApplyPodRequestDefaultTypeInternal;
extern ApplyPodRequestDefaultTypeInternal _ApplyPodRequest_default_instance_;
class ApplyServiceRequest;
struct ApplyServiceRequestDefaultTypeInternal;
extern ApplyServiceRequestDefaultTypeInternal _ApplyServiceRequest_default_instance_;
class DeleteDeploymentRequest;
struct DeleteDeploymentRequestDefaultTypeInternal;
extern DeleteDeploymentRequestDefaultTypeInternal _DeleteDeploymentRequest_default_instance_;
class DeletePodRequest;
struct DeletePodRequestDefaultTypeInternal;
extern DeletePodRequestDefaultTypeInternal _DeletePodRequest_default_instance_;
class DeleteServiceRequest;
struct DeleteServiceRequestDefaultTypeInternal;
extern DeleteServiceRequestDefaultTypeInternal _DeleteServiceRequest_default_instance_;
class GetDeploymentRequest;
struct GetDeploymentRequestDefaultTypeInternal;
extern GetDeploymentRequestDefaultTypeInternal _GetDeploymentRequest_default_instance_;
class GetDeploymentResponse;
struct GetDeploymentResponseDefaultTypeInternal;
extern GetDeploymentResponseDefaultTypeInternal _GetDeploymentResponse_default_instance_;
class GetNodeRequest;
struct GetNodeRequestDefaultTypeInternal;
extern GetNodeRequestDefaultTypeInternal _GetNodeRequest_default_instance_;
class GetNodeResponse;
struct GetNodeResponseDefaultTypeInternal;
extern GetNodeResponseDefaultTypeInternal _GetNodeResponse_default_instance_;
class GetPodRequest;
struct GetPodRequestDefaultTypeInternal;
extern GetPodRequestDefaultTypeInternal _GetPodRequest_default_instance_;
class GetPodResponse;
struct GetPodResponseDefaultTypeInternal;
extern GetPodResponseDefaultTypeInternal _GetPodResponse_default_instance_;
class GetServiceRequest;
struct GetServiceRequestDefaultTypeInternal;
extern GetServiceRequestDefaultTypeInternal _GetServiceRequest_default_instance_;
class GetServiceResponse;
struct GetServiceResponseDefaultTypeInternal;
extern GetServiceResponseDefaultTypeInternal _GetServiceResponse_default_instance_;
class HelloRequest;
struct HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class HelloResponse;
struct HelloResponseDefaultTypeInternal;
extern HelloResponseDefaultTypeInternal _HelloResponse_default_instance_;
class RegisterNodeRequest;
struct RegisterNodeRequestDefaultTypeInternal;
extern RegisterNodeRequestDefaultTypeInternal _RegisterNodeRequest_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class UpdatePodStatusRequest;
struct UpdatePodStatusRequestDefaultTypeInternal;
extern UpdatePodStatusRequestDefaultTypeInternal _UpdatePodStatusRequest_default_instance_;
}  // namespace share
PROTOBUF_NAMESPACE_OPEN
template<> ::share::ApplyDeploymentRequest* Arena::CreateMaybeMessage<::share::ApplyDeploymentRequest>(Arena*);
template<> ::share::ApplyPodRequest* Arena::CreateMaybeMessage<::share::ApplyPodRequest>(Arena*);
template<> ::share::ApplyServiceRequest* Arena::CreateMaybeMessage<::share::ApplyServiceRequest>(Arena*);
template<> ::share::DeleteDeploymentRequest* Arena::CreateMaybeMessage<::share::DeleteDeploymentRequest>(Arena*);
template<> ::share::DeletePodRequest* Arena::CreateMaybeMessage<::share::DeletePodRequest>(Arena*);
template<> ::share::DeleteServiceRequest* Arena::CreateMaybeMessage<::share::DeleteServiceRequest>(Arena*);
template<> ::share::GetDeploymentRequest* Arena::CreateMaybeMessage<::share::GetDeploymentRequest>(Arena*);
template<> ::share::GetDeploymentResponse* Arena::CreateMaybeMessage<::share::GetDeploymentResponse>(Arena*);
template<> ::share::GetNodeRequest* Arena::CreateMaybeMessage<::share::GetNodeRequest>(Arena*);
template<> ::share::GetNodeResponse* Arena::CreateMaybeMessage<::share::GetNodeResponse>(Arena*);
template<> ::share::GetPodRequest* Arena::CreateMaybeMessage<::share::GetPodRequest>(Arena*);
template<> ::share::GetPodResponse* Arena::CreateMaybeMessage<::share::GetPodResponse>(Arena*);
template<> ::share::GetServiceRequest* Arena::CreateMaybeMessage<::share::GetServiceRequest>(Arena*);
template<> ::share::GetServiceResponse* Arena::CreateMaybeMessage<::share::GetServiceResponse>(Arena*);
template<> ::share::HelloRequest* Arena::CreateMaybeMessage<::share::HelloRequest>(Arena*);
template<> ::share::HelloResponse* Arena::CreateMaybeMessage<::share::HelloResponse>(Arena*);
template<> ::share::RegisterNodeRequest* Arena::CreateMaybeMessage<::share::RegisterNodeRequest>(Arena*);
template<> ::share::StatusResponse* Arena::CreateMaybeMessage<::share::StatusResponse>(Arena*);
template<> ::share::UpdatePodStatusRequest* Arena::CreateMaybeMessage<::share::UpdatePodStatusRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace share {

// ===================================================================

class HelloRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  ~HelloRequest() override;
  explicit PROTOBUF_CONSTEXPR HelloRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloRequest& from) {
    HelloRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:share.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class HelloResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.HelloResponse) */ {
 public:
  inline HelloResponse() : HelloResponse(nullptr) {}
  ~HelloResponse() override;
  explicit PROTOBUF_CONSTEXPR HelloResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloResponse(const HelloResponse& from);
  HelloResponse(HelloResponse&& from) noexcept
    : HelloResponse() {
    *this = ::std::move(from);
  }

  inline HelloResponse& operator=(const HelloResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloResponse& operator=(HelloResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloResponse* internal_default_instance() {
    return reinterpret_cast<const HelloResponse*>(
               &_HelloResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HelloResponse& a, HelloResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloResponse& from) {
    HelloResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.HelloResponse";
  }
  protected:
  explicit HelloResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 1,
  };
  // string reply = 1;
  void clear_reply();
  const std::string& reply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply();
  PROTOBUF_NODISCARD std::string* release_reply();
  void set_allocated_reply(std::string* reply);
  private:
  const std::string& _internal_reply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply(const std::string& value);
  std::string* _internal_mutable_reply();
  public:

  // @@protoc_insertion_point(class_scope:share.HelloResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class ApplyPodRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.ApplyPodRequest) */ {
 public:
  inline ApplyPodRequest() : ApplyPodRequest(nullptr) {}
  ~ApplyPodRequest() override;
  explicit PROTOBUF_CONSTEXPR ApplyPodRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyPodRequest(const ApplyPodRequest& from);
  ApplyPodRequest(ApplyPodRequest&& from) noexcept
    : ApplyPodRequest() {
    *this = ::std::move(from);
  }

  inline ApplyPodRequest& operator=(const ApplyPodRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyPodRequest& operator=(ApplyPodRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyPodRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyPodRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyPodRequest*>(
               &_ApplyPodRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ApplyPodRequest& a, ApplyPodRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyPodRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyPodRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyPodRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyPodRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyPodRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyPodRequest& from) {
    ApplyPodRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyPodRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.ApplyPodRequest";
  }
  protected:
  explicit ApplyPodRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:share.ApplyPodRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class DeletePodRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.DeletePodRequest) */ {
 public:
  inline DeletePodRequest() : DeletePodRequest(nullptr) {}
  ~DeletePodRequest() override;
  explicit PROTOBUF_CONSTEXPR DeletePodRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePodRequest(const DeletePodRequest& from);
  DeletePodRequest(DeletePodRequest&& from) noexcept
    : DeletePodRequest() {
    *this = ::std::move(from);
  }

  inline DeletePodRequest& operator=(const DeletePodRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePodRequest& operator=(DeletePodRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePodRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePodRequest* internal_default_instance() {
    return reinterpret_cast<const DeletePodRequest*>(
               &_DeletePodRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeletePodRequest& a, DeletePodRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePodRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePodRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePodRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeletePodRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePodRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeletePodRequest& from) {
    DeletePodRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePodRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.DeletePodRequest";
  }
  protected:
  explicit DeletePodRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:share.DeletePodRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class GetPodRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.GetPodRequest) */ {
 public:
  inline GetPodRequest() : GetPodRequest(nullptr) {}
  ~GetPodRequest() override;
  explicit PROTOBUF_CONSTEXPR GetPodRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPodRequest(const GetPodRequest& from);
  GetPodRequest(GetPodRequest&& from) noexcept
    : GetPodRequest() {
    *this = ::std::move(from);
  }

  inline GetPodRequest& operator=(const GetPodRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPodRequest& operator=(GetPodRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPodRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPodRequest* internal_default_instance() {
    return reinterpret_cast<const GetPodRequest*>(
               &_GetPodRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetPodRequest& a, GetPodRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPodRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPodRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPodRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPodRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPodRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPodRequest& from) {
    GetPodRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPodRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.GetPodRequest";
  }
  protected:
  explicit GetPodRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPodNameFieldNumber = 1,
  };
  // string PodName = 1;
  void clear_podname();
  const std::string& podname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_podname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_podname();
  PROTOBUF_NODISCARD std::string* release_podname();
  void set_allocated_podname(std::string* podname);
  private:
  const std::string& _internal_podname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_podname(const std::string& value);
  std::string* _internal_mutable_podname();
  public:

  // @@protoc_insertion_point(class_scope:share.GetPodRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr podname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class GetPodResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.GetPodResponse) */ {
 public:
  inline GetPodResponse() : GetPodResponse(nullptr) {}
  ~GetPodResponse() override;
  explicit PROTOBUF_CONSTEXPR GetPodResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPodResponse(const GetPodResponse& from);
  GetPodResponse(GetPodResponse&& from) noexcept
    : GetPodResponse() {
    *this = ::std::move(from);
  }

  inline GetPodResponse& operator=(const GetPodResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPodResponse& operator=(GetPodResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPodResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPodResponse* internal_default_instance() {
    return reinterpret_cast<const GetPodResponse*>(
               &_GetPodResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetPodResponse& a, GetPodResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPodResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPodResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPodResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPodResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPodResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPodResponse& from) {
    GetPodResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPodResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.GetPodResponse";
  }
  protected:
  explicit GetPodResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPodDataFieldNumber = 1,
  };
  // bytes PodData = 1;
  void clear_poddata();
  const std::string& poddata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_poddata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_poddata();
  PROTOBUF_NODISCARD std::string* release_poddata();
  void set_allocated_poddata(std::string* poddata);
  private:
  const std::string& _internal_poddata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_poddata(const std::string& value);
  std::string* _internal_mutable_poddata();
  public:

  // @@protoc_insertion_point(class_scope:share.GetPodResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr poddata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  explicit PROTOBUF_CONSTEXPR StatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.StatusResponse";
  }
  protected:
  explicit StatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int32 status = 1;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:share.StatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class RegisterNodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.RegisterNodeRequest) */ {
 public:
  inline RegisterNodeRequest() : RegisterNodeRequest(nullptr) {}
  ~RegisterNodeRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterNodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterNodeRequest(const RegisterNodeRequest& from);
  RegisterNodeRequest(RegisterNodeRequest&& from) noexcept
    : RegisterNodeRequest() {
    *this = ::std::move(from);
  }

  inline RegisterNodeRequest& operator=(const RegisterNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterNodeRequest& operator=(RegisterNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterNodeRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterNodeRequest*>(
               &_RegisterNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegisterNodeRequest& a, RegisterNodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterNodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterNodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterNodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterNodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterNodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterNodeRequest& from) {
    RegisterNodeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterNodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.RegisterNodeRequest";
  }
  protected:
  explicit RegisterNodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 1,
    kNodeIpFieldNumber = 2,
    kKubeletUrlFieldNumber = 3,
  };
  // string NodeName = 1;
  void clear_nodename();
  const std::string& nodename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nodename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nodename();
  PROTOBUF_NODISCARD std::string* release_nodename();
  void set_allocated_nodename(std::string* nodename);
  private:
  const std::string& _internal_nodename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodename(const std::string& value);
  std::string* _internal_mutable_nodename();
  public:

  // string NodeIp = 2;
  void clear_nodeip();
  const std::string& nodeip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nodeip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nodeip();
  PROTOBUF_NODISCARD std::string* release_nodeip();
  void set_allocated_nodeip(std::string* nodeip);
  private:
  const std::string& _internal_nodeip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodeip(const std::string& value);
  std::string* _internal_mutable_nodeip();
  public:

  // string kubelet_url = 3;
  void clear_kubelet_url();
  const std::string& kubelet_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kubelet_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kubelet_url();
  PROTOBUF_NODISCARD std::string* release_kubelet_url();
  void set_allocated_kubelet_url(std::string* kubelet_url);
  private:
  const std::string& _internal_kubelet_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kubelet_url(const std::string& value);
  std::string* _internal_mutable_kubelet_url();
  public:

  // @@protoc_insertion_point(class_scope:share.RegisterNodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodeip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kubelet_url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class UpdatePodStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.UpdatePodStatusRequest) */ {
 public:
  inline UpdatePodStatusRequest() : UpdatePodStatusRequest(nullptr) {}
  ~UpdatePodStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdatePodStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePodStatusRequest(const UpdatePodStatusRequest& from);
  UpdatePodStatusRequest(UpdatePodStatusRequest&& from) noexcept
    : UpdatePodStatusRequest() {
    *this = ::std::move(from);
  }

  inline UpdatePodStatusRequest& operator=(const UpdatePodStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePodStatusRequest& operator=(UpdatePodStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePodStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePodStatusRequest* internal_default_instance() {
    return reinterpret_cast<const UpdatePodStatusRequest*>(
               &_UpdatePodStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdatePodStatusRequest& a, UpdatePodStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePodStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePodStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePodStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePodStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePodStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdatePodStatusRequest& from) {
    UpdatePodStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePodStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.UpdatePodStatusRequest";
  }
  protected:
  explicit UpdatePodStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:share.UpdatePodStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class ApplyDeploymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.ApplyDeploymentRequest) */ {
 public:
  inline ApplyDeploymentRequest() : ApplyDeploymentRequest(nullptr) {}
  ~ApplyDeploymentRequest() override;
  explicit PROTOBUF_CONSTEXPR ApplyDeploymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyDeploymentRequest(const ApplyDeploymentRequest& from);
  ApplyDeploymentRequest(ApplyDeploymentRequest&& from) noexcept
    : ApplyDeploymentRequest() {
    *this = ::std::move(from);
  }

  inline ApplyDeploymentRequest& operator=(const ApplyDeploymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyDeploymentRequest& operator=(ApplyDeploymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyDeploymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyDeploymentRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyDeploymentRequest*>(
               &_ApplyDeploymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ApplyDeploymentRequest& a, ApplyDeploymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyDeploymentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyDeploymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyDeploymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyDeploymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyDeploymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyDeploymentRequest& from) {
    ApplyDeploymentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyDeploymentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.ApplyDeploymentRequest";
  }
  protected:
  explicit ApplyDeploymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:share.ApplyDeploymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class GetDeploymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.GetDeploymentRequest) */ {
 public:
  inline GetDeploymentRequest() : GetDeploymentRequest(nullptr) {}
  ~GetDeploymentRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDeploymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDeploymentRequest(const GetDeploymentRequest& from);
  GetDeploymentRequest(GetDeploymentRequest&& from) noexcept
    : GetDeploymentRequest() {
    *this = ::std::move(from);
  }

  inline GetDeploymentRequest& operator=(const GetDeploymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDeploymentRequest& operator=(GetDeploymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDeploymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDeploymentRequest* internal_default_instance() {
    return reinterpret_cast<const GetDeploymentRequest*>(
               &_GetDeploymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetDeploymentRequest& a, GetDeploymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDeploymentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDeploymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDeploymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDeploymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDeploymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDeploymentRequest& from) {
    GetDeploymentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDeploymentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.GetDeploymentRequest";
  }
  protected:
  explicit GetDeploymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeploymentNameFieldNumber = 1,
  };
  // string DeploymentName = 1;
  void clear_deploymentname();
  const std::string& deploymentname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deploymentname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deploymentname();
  PROTOBUF_NODISCARD std::string* release_deploymentname();
  void set_allocated_deploymentname(std::string* deploymentname);
  private:
  const std::string& _internal_deploymentname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deploymentname(const std::string& value);
  std::string* _internal_mutable_deploymentname();
  public:

  // @@protoc_insertion_point(class_scope:share.GetDeploymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deploymentname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class DeleteDeploymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.DeleteDeploymentRequest) */ {
 public:
  inline DeleteDeploymentRequest() : DeleteDeploymentRequest(nullptr) {}
  ~DeleteDeploymentRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteDeploymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteDeploymentRequest(const DeleteDeploymentRequest& from);
  DeleteDeploymentRequest(DeleteDeploymentRequest&& from) noexcept
    : DeleteDeploymentRequest() {
    *this = ::std::move(from);
  }

  inline DeleteDeploymentRequest& operator=(const DeleteDeploymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDeploymentRequest& operator=(DeleteDeploymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDeploymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteDeploymentRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteDeploymentRequest*>(
               &_DeleteDeploymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteDeploymentRequest& a, DeleteDeploymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteDeploymentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDeploymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDeploymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteDeploymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteDeploymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteDeploymentRequest& from) {
    DeleteDeploymentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteDeploymentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.DeleteDeploymentRequest";
  }
  protected:
  explicit DeleteDeploymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeploymentNameFieldNumber = 1,
  };
  // string DeploymentName = 1;
  void clear_deploymentname();
  const std::string& deploymentname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deploymentname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deploymentname();
  PROTOBUF_NODISCARD std::string* release_deploymentname();
  void set_allocated_deploymentname(std::string* deploymentname);
  private:
  const std::string& _internal_deploymentname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deploymentname(const std::string& value);
  std::string* _internal_mutable_deploymentname();
  public:

  // @@protoc_insertion_point(class_scope:share.DeleteDeploymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deploymentname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class GetDeploymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.GetDeploymentResponse) */ {
 public:
  inline GetDeploymentResponse() : GetDeploymentResponse(nullptr) {}
  ~GetDeploymentResponse() override;
  explicit PROTOBUF_CONSTEXPR GetDeploymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDeploymentResponse(const GetDeploymentResponse& from);
  GetDeploymentResponse(GetDeploymentResponse&& from) noexcept
    : GetDeploymentResponse() {
    *this = ::std::move(from);
  }

  inline GetDeploymentResponse& operator=(const GetDeploymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDeploymentResponse& operator=(GetDeploymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDeploymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDeploymentResponse* internal_default_instance() {
    return reinterpret_cast<const GetDeploymentResponse*>(
               &_GetDeploymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetDeploymentResponse& a, GetDeploymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDeploymentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDeploymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDeploymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDeploymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDeploymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDeploymentResponse& from) {
    GetDeploymentResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDeploymentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.GetDeploymentResponse";
  }
  protected:
  explicit GetDeploymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:share.GetDeploymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class ApplyServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.ApplyServiceRequest) */ {
 public:
  inline ApplyServiceRequest() : ApplyServiceRequest(nullptr) {}
  ~ApplyServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR ApplyServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyServiceRequest(const ApplyServiceRequest& from);
  ApplyServiceRequest(ApplyServiceRequest&& from) noexcept
    : ApplyServiceRequest() {
    *this = ::std::move(from);
  }

  inline ApplyServiceRequest& operator=(const ApplyServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyServiceRequest& operator=(ApplyServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyServiceRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyServiceRequest*>(
               &_ApplyServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ApplyServiceRequest& a, ApplyServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyServiceRequest& from) {
    ApplyServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.ApplyServiceRequest";
  }
  protected:
  explicit ApplyServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:share.ApplyServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class GetServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.GetServiceRequest) */ {
 public:
  inline GetServiceRequest() : GetServiceRequest(nullptr) {}
  ~GetServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR GetServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceRequest(const GetServiceRequest& from);
  GetServiceRequest(GetServiceRequest&& from) noexcept
    : GetServiceRequest() {
    *this = ::std::move(from);
  }

  inline GetServiceRequest& operator=(const GetServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceRequest& operator=(GetServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceRequest* internal_default_instance() {
    return reinterpret_cast<const GetServiceRequest*>(
               &_GetServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetServiceRequest& a, GetServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceRequest& from) {
    GetServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.GetServiceRequest";
  }
  protected:
  explicit GetServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
  };
  // string ServiceName = 1;
  void clear_servicename();
  const std::string& servicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servicename();
  PROTOBUF_NODISCARD std::string* release_servicename();
  void set_allocated_servicename(std::string* servicename);
  private:
  const std::string& _internal_servicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servicename(const std::string& value);
  std::string* _internal_mutable_servicename();
  public:

  // @@protoc_insertion_point(class_scope:share.GetServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servicename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class DeleteServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.DeleteServiceRequest) */ {
 public:
  inline DeleteServiceRequest() : DeleteServiceRequest(nullptr) {}
  ~DeleteServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteServiceRequest(const DeleteServiceRequest& from);
  DeleteServiceRequest(DeleteServiceRequest&& from) noexcept
    : DeleteServiceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteServiceRequest& operator=(const DeleteServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteServiceRequest& operator=(DeleteServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteServiceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteServiceRequest*>(
               &_DeleteServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DeleteServiceRequest& a, DeleteServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteServiceRequest& from) {
    DeleteServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.DeleteServiceRequest";
  }
  protected:
  explicit DeleteServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
  };
  // string ServiceName = 1;
  void clear_servicename();
  const std::string& servicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servicename();
  PROTOBUF_NODISCARD std::string* release_servicename();
  void set_allocated_servicename(std::string* servicename);
  private:
  const std::string& _internal_servicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servicename(const std::string& value);
  std::string* _internal_mutable_servicename();
  public:

  // @@protoc_insertion_point(class_scope:share.DeleteServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servicename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class GetServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.GetServiceResponse) */ {
 public:
  inline GetServiceResponse() : GetServiceResponse(nullptr) {}
  ~GetServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR GetServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceResponse(const GetServiceResponse& from);
  GetServiceResponse(GetServiceResponse&& from) noexcept
    : GetServiceResponse() {
    *this = ::std::move(from);
  }

  inline GetServiceResponse& operator=(const GetServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceResponse& operator=(GetServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceResponse* internal_default_instance() {
    return reinterpret_cast<const GetServiceResponse*>(
               &_GetServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetServiceResponse& a, GetServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceResponse& from) {
    GetServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.GetServiceResponse";
  }
  protected:
  explicit GetServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:share.GetServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class GetNodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.GetNodeRequest) */ {
 public:
  inline GetNodeRequest() : GetNodeRequest(nullptr) {}
  ~GetNodeRequest() override;
  explicit PROTOBUF_CONSTEXPR GetNodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNodeRequest(const GetNodeRequest& from);
  GetNodeRequest(GetNodeRequest&& from) noexcept
    : GetNodeRequest() {
    *this = ::std::move(from);
  }

  inline GetNodeRequest& operator=(const GetNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodeRequest& operator=(GetNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodeRequest* internal_default_instance() {
    return reinterpret_cast<const GetNodeRequest*>(
               &_GetNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetNodeRequest& a, GetNodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNodeRequest& from) {
    GetNodeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.GetNodeRequest";
  }
  protected:
  explicit GetNodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 1,
  };
  // string NodeName = 1;
  void clear_nodename();
  const std::string& nodename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nodename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nodename();
  PROTOBUF_NODISCARD std::string* release_nodename();
  void set_allocated_nodename(std::string* nodename);
  private:
  const std::string& _internal_nodename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodename(const std::string& value);
  std::string* _internal_mutable_nodename();
  public:

  // @@protoc_insertion_point(class_scope:share.GetNodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// -------------------------------------------------------------------

class GetNodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:share.GetNodeResponse) */ {
 public:
  inline GetNodeResponse() : GetNodeResponse(nullptr) {}
  ~GetNodeResponse() override;
  explicit PROTOBUF_CONSTEXPR GetNodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNodeResponse(const GetNodeResponse& from);
  GetNodeResponse(GetNodeResponse&& from) noexcept
    : GetNodeResponse() {
    *this = ::std::move(from);
  }

  inline GetNodeResponse& operator=(const GetNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodeResponse& operator=(GetNodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodeResponse* internal_default_instance() {
    return reinterpret_cast<const GetNodeResponse*>(
               &_GetNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetNodeResponse& a, GetNodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNodeResponse& from) {
    GetNodeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "share.GetNodeResponse";
  }
  protected:
  explicit GetNodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeDataFieldNumber = 1,
  };
  // bytes NodeData = 1;
  void clear_nodedata();
  const std::string& nodedata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nodedata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nodedata();
  PROTOBUF_NODISCARD std::string* release_nodedata();
  void set_allocated_nodedata(std::string* nodedata);
  private:
  const std::string& _internal_nodedata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodedata(const std::string& value);
  std::string* _internal_mutable_nodedata();
  public:

  // @@protoc_insertion_point(class_scope:share.GetNodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodedata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_share_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:share.HelloRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:share.HelloRequest.name)
  return _s;
}
inline const std::string& HelloRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HelloRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:share.HelloRequest.name)
  return _impl_.name_.Release();
}
inline void HelloRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloResponse

// string reply = 1;
inline void HelloResponse::clear_reply() {
  _impl_.reply_.ClearToEmpty();
}
inline const std::string& HelloResponse::reply() const {
  // @@protoc_insertion_point(field_get:share.HelloResponse.reply)
  return _internal_reply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloResponse::set_reply(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.HelloResponse.reply)
}
inline std::string* HelloResponse::mutable_reply() {
  std::string* _s = _internal_mutable_reply();
  // @@protoc_insertion_point(field_mutable:share.HelloResponse.reply)
  return _s;
}
inline const std::string& HelloResponse::_internal_reply() const {
  return _impl_.reply_.Get();
}
inline void HelloResponse::_internal_set_reply(const std::string& value) {
  
  _impl_.reply_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloResponse::_internal_mutable_reply() {
  
  return _impl_.reply_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloResponse::release_reply() {
  // @@protoc_insertion_point(field_release:share.HelloResponse.reply)
  return _impl_.reply_.Release();
}
inline void HelloResponse::set_allocated_reply(std::string* reply) {
  if (reply != nullptr) {
    
  } else {
    
  }
  _impl_.reply_.SetAllocated(reply, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_.IsDefault()) {
    _impl_.reply_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.HelloResponse.reply)
}

// -------------------------------------------------------------------

// ApplyPodRequest

// bytes data = 1;
inline void ApplyPodRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ApplyPodRequest::data() const {
  // @@protoc_insertion_point(field_get:share.ApplyPodRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyPodRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.ApplyPodRequest.data)
}
inline std::string* ApplyPodRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:share.ApplyPodRequest.data)
  return _s;
}
inline const std::string& ApplyPodRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ApplyPodRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyPodRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyPodRequest::release_data() {
  // @@protoc_insertion_point(field_release:share.ApplyPodRequest.data)
  return _impl_.data_.Release();
}
inline void ApplyPodRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.ApplyPodRequest.data)
}

// -------------------------------------------------------------------

// DeletePodRequest

// bytes data = 1;
inline void DeletePodRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& DeletePodRequest::data() const {
  // @@protoc_insertion_point(field_get:share.DeletePodRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePodRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.DeletePodRequest.data)
}
inline std::string* DeletePodRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:share.DeletePodRequest.data)
  return _s;
}
inline const std::string& DeletePodRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void DeletePodRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* DeletePodRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* DeletePodRequest::release_data() {
  // @@protoc_insertion_point(field_release:share.DeletePodRequest.data)
  return _impl_.data_.Release();
}
inline void DeletePodRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.DeletePodRequest.data)
}

// -------------------------------------------------------------------

// GetPodRequest

// string PodName = 1;
inline void GetPodRequest::clear_podname() {
  _impl_.podname_.ClearToEmpty();
}
inline const std::string& GetPodRequest::podname() const {
  // @@protoc_insertion_point(field_get:share.GetPodRequest.PodName)
  return _internal_podname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPodRequest::set_podname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.podname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.GetPodRequest.PodName)
}
inline std::string* GetPodRequest::mutable_podname() {
  std::string* _s = _internal_mutable_podname();
  // @@protoc_insertion_point(field_mutable:share.GetPodRequest.PodName)
  return _s;
}
inline const std::string& GetPodRequest::_internal_podname() const {
  return _impl_.podname_.Get();
}
inline void GetPodRequest::_internal_set_podname(const std::string& value) {
  
  _impl_.podname_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPodRequest::_internal_mutable_podname() {
  
  return _impl_.podname_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPodRequest::release_podname() {
  // @@protoc_insertion_point(field_release:share.GetPodRequest.PodName)
  return _impl_.podname_.Release();
}
inline void GetPodRequest::set_allocated_podname(std::string* podname) {
  if (podname != nullptr) {
    
  } else {
    
  }
  _impl_.podname_.SetAllocated(podname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.podname_.IsDefault()) {
    _impl_.podname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.GetPodRequest.PodName)
}

// -------------------------------------------------------------------

// GetPodResponse

// bytes PodData = 1;
inline void GetPodResponse::clear_poddata() {
  _impl_.poddata_.ClearToEmpty();
}
inline const std::string& GetPodResponse::poddata() const {
  // @@protoc_insertion_point(field_get:share.GetPodResponse.PodData)
  return _internal_poddata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPodResponse::set_poddata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.poddata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.GetPodResponse.PodData)
}
inline std::string* GetPodResponse::mutable_poddata() {
  std::string* _s = _internal_mutable_poddata();
  // @@protoc_insertion_point(field_mutable:share.GetPodResponse.PodData)
  return _s;
}
inline const std::string& GetPodResponse::_internal_poddata() const {
  return _impl_.poddata_.Get();
}
inline void GetPodResponse::_internal_set_poddata(const std::string& value) {
  
  _impl_.poddata_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPodResponse::_internal_mutable_poddata() {
  
  return _impl_.poddata_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPodResponse::release_poddata() {
  // @@protoc_insertion_point(field_release:share.GetPodResponse.PodData)
  return _impl_.poddata_.Release();
}
inline void GetPodResponse::set_allocated_poddata(std::string* poddata) {
  if (poddata != nullptr) {
    
  } else {
    
  }
  _impl_.poddata_.SetAllocated(poddata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.poddata_.IsDefault()) {
    _impl_.poddata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.GetPodResponse.PodData)
}

// -------------------------------------------------------------------

// StatusResponse

// int32 status = 1;
inline void StatusResponse::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t StatusResponse::_internal_status() const {
  return _impl_.status_;
}
inline int32_t StatusResponse::status() const {
  // @@protoc_insertion_point(field_get:share.StatusResponse.status)
  return _internal_status();
}
inline void StatusResponse::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void StatusResponse::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:share.StatusResponse.status)
}

// -------------------------------------------------------------------

// RegisterNodeRequest

// string NodeName = 1;
inline void RegisterNodeRequest::clear_nodename() {
  _impl_.nodename_.ClearToEmpty();
}
inline const std::string& RegisterNodeRequest::nodename() const {
  // @@protoc_insertion_point(field_get:share.RegisterNodeRequest.NodeName)
  return _internal_nodename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterNodeRequest::set_nodename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nodename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.RegisterNodeRequest.NodeName)
}
inline std::string* RegisterNodeRequest::mutable_nodename() {
  std::string* _s = _internal_mutable_nodename();
  // @@protoc_insertion_point(field_mutable:share.RegisterNodeRequest.NodeName)
  return _s;
}
inline const std::string& RegisterNodeRequest::_internal_nodename() const {
  return _impl_.nodename_.Get();
}
inline void RegisterNodeRequest::_internal_set_nodename(const std::string& value) {
  
  _impl_.nodename_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterNodeRequest::_internal_mutable_nodename() {
  
  return _impl_.nodename_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterNodeRequest::release_nodename() {
  // @@protoc_insertion_point(field_release:share.RegisterNodeRequest.NodeName)
  return _impl_.nodename_.Release();
}
inline void RegisterNodeRequest::set_allocated_nodename(std::string* nodename) {
  if (nodename != nullptr) {
    
  } else {
    
  }
  _impl_.nodename_.SetAllocated(nodename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nodename_.IsDefault()) {
    _impl_.nodename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.RegisterNodeRequest.NodeName)
}

// string NodeIp = 2;
inline void RegisterNodeRequest::clear_nodeip() {
  _impl_.nodeip_.ClearToEmpty();
}
inline const std::string& RegisterNodeRequest::nodeip() const {
  // @@protoc_insertion_point(field_get:share.RegisterNodeRequest.NodeIp)
  return _internal_nodeip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterNodeRequest::set_nodeip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nodeip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.RegisterNodeRequest.NodeIp)
}
inline std::string* RegisterNodeRequest::mutable_nodeip() {
  std::string* _s = _internal_mutable_nodeip();
  // @@protoc_insertion_point(field_mutable:share.RegisterNodeRequest.NodeIp)
  return _s;
}
inline const std::string& RegisterNodeRequest::_internal_nodeip() const {
  return _impl_.nodeip_.Get();
}
inline void RegisterNodeRequest::_internal_set_nodeip(const std::string& value) {
  
  _impl_.nodeip_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterNodeRequest::_internal_mutable_nodeip() {
  
  return _impl_.nodeip_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterNodeRequest::release_nodeip() {
  // @@protoc_insertion_point(field_release:share.RegisterNodeRequest.NodeIp)
  return _impl_.nodeip_.Release();
}
inline void RegisterNodeRequest::set_allocated_nodeip(std::string* nodeip) {
  if (nodeip != nullptr) {
    
  } else {
    
  }
  _impl_.nodeip_.SetAllocated(nodeip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nodeip_.IsDefault()) {
    _impl_.nodeip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.RegisterNodeRequest.NodeIp)
}

// string kubelet_url = 3;
inline void RegisterNodeRequest::clear_kubelet_url() {
  _impl_.kubelet_url_.ClearToEmpty();
}
inline const std::string& RegisterNodeRequest::kubelet_url() const {
  // @@protoc_insertion_point(field_get:share.RegisterNodeRequest.kubelet_url)
  return _internal_kubelet_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterNodeRequest::set_kubelet_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.kubelet_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.RegisterNodeRequest.kubelet_url)
}
inline std::string* RegisterNodeRequest::mutable_kubelet_url() {
  std::string* _s = _internal_mutable_kubelet_url();
  // @@protoc_insertion_point(field_mutable:share.RegisterNodeRequest.kubelet_url)
  return _s;
}
inline const std::string& RegisterNodeRequest::_internal_kubelet_url() const {
  return _impl_.kubelet_url_.Get();
}
inline void RegisterNodeRequest::_internal_set_kubelet_url(const std::string& value) {
  
  _impl_.kubelet_url_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterNodeRequest::_internal_mutable_kubelet_url() {
  
  return _impl_.kubelet_url_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterNodeRequest::release_kubelet_url() {
  // @@protoc_insertion_point(field_release:share.RegisterNodeRequest.kubelet_url)
  return _impl_.kubelet_url_.Release();
}
inline void RegisterNodeRequest::set_allocated_kubelet_url(std::string* kubelet_url) {
  if (kubelet_url != nullptr) {
    
  } else {
    
  }
  _impl_.kubelet_url_.SetAllocated(kubelet_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kubelet_url_.IsDefault()) {
    _impl_.kubelet_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.RegisterNodeRequest.kubelet_url)
}

// -------------------------------------------------------------------

// UpdatePodStatusRequest

// bytes data = 1;
inline void UpdatePodStatusRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& UpdatePodStatusRequest::data() const {
  // @@protoc_insertion_point(field_get:share.UpdatePodStatusRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePodStatusRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.UpdatePodStatusRequest.data)
}
inline std::string* UpdatePodStatusRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:share.UpdatePodStatusRequest.data)
  return _s;
}
inline const std::string& UpdatePodStatusRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void UpdatePodStatusRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdatePodStatusRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdatePodStatusRequest::release_data() {
  // @@protoc_insertion_point(field_release:share.UpdatePodStatusRequest.data)
  return _impl_.data_.Release();
}
inline void UpdatePodStatusRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.UpdatePodStatusRequest.data)
}

// -------------------------------------------------------------------

// ApplyDeploymentRequest

// bytes data = 1;
inline void ApplyDeploymentRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ApplyDeploymentRequest::data() const {
  // @@protoc_insertion_point(field_get:share.ApplyDeploymentRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyDeploymentRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.ApplyDeploymentRequest.data)
}
inline std::string* ApplyDeploymentRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:share.ApplyDeploymentRequest.data)
  return _s;
}
inline const std::string& ApplyDeploymentRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ApplyDeploymentRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyDeploymentRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyDeploymentRequest::release_data() {
  // @@protoc_insertion_point(field_release:share.ApplyDeploymentRequest.data)
  return _impl_.data_.Release();
}
inline void ApplyDeploymentRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.ApplyDeploymentRequest.data)
}

// -------------------------------------------------------------------

// GetDeploymentRequest

// string DeploymentName = 1;
inline void GetDeploymentRequest::clear_deploymentname() {
  _impl_.deploymentname_.ClearToEmpty();
}
inline const std::string& GetDeploymentRequest::deploymentname() const {
  // @@protoc_insertion_point(field_get:share.GetDeploymentRequest.DeploymentName)
  return _internal_deploymentname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDeploymentRequest::set_deploymentname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deploymentname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.GetDeploymentRequest.DeploymentName)
}
inline std::string* GetDeploymentRequest::mutable_deploymentname() {
  std::string* _s = _internal_mutable_deploymentname();
  // @@protoc_insertion_point(field_mutable:share.GetDeploymentRequest.DeploymentName)
  return _s;
}
inline const std::string& GetDeploymentRequest::_internal_deploymentname() const {
  return _impl_.deploymentname_.Get();
}
inline void GetDeploymentRequest::_internal_set_deploymentname(const std::string& value) {
  
  _impl_.deploymentname_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDeploymentRequest::_internal_mutable_deploymentname() {
  
  return _impl_.deploymentname_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDeploymentRequest::release_deploymentname() {
  // @@protoc_insertion_point(field_release:share.GetDeploymentRequest.DeploymentName)
  return _impl_.deploymentname_.Release();
}
inline void GetDeploymentRequest::set_allocated_deploymentname(std::string* deploymentname) {
  if (deploymentname != nullptr) {
    
  } else {
    
  }
  _impl_.deploymentname_.SetAllocated(deploymentname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deploymentname_.IsDefault()) {
    _impl_.deploymentname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.GetDeploymentRequest.DeploymentName)
}

// -------------------------------------------------------------------

// DeleteDeploymentRequest

// string DeploymentName = 1;
inline void DeleteDeploymentRequest::clear_deploymentname() {
  _impl_.deploymentname_.ClearToEmpty();
}
inline const std::string& DeleteDeploymentRequest::deploymentname() const {
  // @@protoc_insertion_point(field_get:share.DeleteDeploymentRequest.DeploymentName)
  return _internal_deploymentname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteDeploymentRequest::set_deploymentname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deploymentname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.DeleteDeploymentRequest.DeploymentName)
}
inline std::string* DeleteDeploymentRequest::mutable_deploymentname() {
  std::string* _s = _internal_mutable_deploymentname();
  // @@protoc_insertion_point(field_mutable:share.DeleteDeploymentRequest.DeploymentName)
  return _s;
}
inline const std::string& DeleteDeploymentRequest::_internal_deploymentname() const {
  return _impl_.deploymentname_.Get();
}
inline void DeleteDeploymentRequest::_internal_set_deploymentname(const std::string& value) {
  
  _impl_.deploymentname_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteDeploymentRequest::_internal_mutable_deploymentname() {
  
  return _impl_.deploymentname_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteDeploymentRequest::release_deploymentname() {
  // @@protoc_insertion_point(field_release:share.DeleteDeploymentRequest.DeploymentName)
  return _impl_.deploymentname_.Release();
}
inline void DeleteDeploymentRequest::set_allocated_deploymentname(std::string* deploymentname) {
  if (deploymentname != nullptr) {
    
  } else {
    
  }
  _impl_.deploymentname_.SetAllocated(deploymentname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deploymentname_.IsDefault()) {
    _impl_.deploymentname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.DeleteDeploymentRequest.DeploymentName)
}

// -------------------------------------------------------------------

// GetDeploymentResponse

// bytes data = 1;
inline void GetDeploymentResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& GetDeploymentResponse::data() const {
  // @@protoc_insertion_point(field_get:share.GetDeploymentResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDeploymentResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.GetDeploymentResponse.data)
}
inline std::string* GetDeploymentResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:share.GetDeploymentResponse.data)
  return _s;
}
inline const std::string& GetDeploymentResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void GetDeploymentResponse::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDeploymentResponse::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDeploymentResponse::release_data() {
  // @@protoc_insertion_point(field_release:share.GetDeploymentResponse.data)
  return _impl_.data_.Release();
}
inline void GetDeploymentResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.GetDeploymentResponse.data)
}

// -------------------------------------------------------------------

// ApplyServiceRequest

// bytes data = 1;
inline void ApplyServiceRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ApplyServiceRequest::data() const {
  // @@protoc_insertion_point(field_get:share.ApplyServiceRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyServiceRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.ApplyServiceRequest.data)
}
inline std::string* ApplyServiceRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:share.ApplyServiceRequest.data)
  return _s;
}
inline const std::string& ApplyServiceRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ApplyServiceRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyServiceRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyServiceRequest::release_data() {
  // @@protoc_insertion_point(field_release:share.ApplyServiceRequest.data)
  return _impl_.data_.Release();
}
inline void ApplyServiceRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.ApplyServiceRequest.data)
}

// -------------------------------------------------------------------

// GetServiceRequest

// string ServiceName = 1;
inline void GetServiceRequest::clear_servicename() {
  _impl_.servicename_.ClearToEmpty();
}
inline const std::string& GetServiceRequest::servicename() const {
  // @@protoc_insertion_point(field_get:share.GetServiceRequest.ServiceName)
  return _internal_servicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceRequest::set_servicename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servicename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.GetServiceRequest.ServiceName)
}
inline std::string* GetServiceRequest::mutable_servicename() {
  std::string* _s = _internal_mutable_servicename();
  // @@protoc_insertion_point(field_mutable:share.GetServiceRequest.ServiceName)
  return _s;
}
inline const std::string& GetServiceRequest::_internal_servicename() const {
  return _impl_.servicename_.Get();
}
inline void GetServiceRequest::_internal_set_servicename(const std::string& value) {
  
  _impl_.servicename_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceRequest::_internal_mutable_servicename() {
  
  return _impl_.servicename_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceRequest::release_servicename() {
  // @@protoc_insertion_point(field_release:share.GetServiceRequest.ServiceName)
  return _impl_.servicename_.Release();
}
inline void GetServiceRequest::set_allocated_servicename(std::string* servicename) {
  if (servicename != nullptr) {
    
  } else {
    
  }
  _impl_.servicename_.SetAllocated(servicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servicename_.IsDefault()) {
    _impl_.servicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.GetServiceRequest.ServiceName)
}

// -------------------------------------------------------------------

// DeleteServiceRequest

// string ServiceName = 1;
inline void DeleteServiceRequest::clear_servicename() {
  _impl_.servicename_.ClearToEmpty();
}
inline const std::string& DeleteServiceRequest::servicename() const {
  // @@protoc_insertion_point(field_get:share.DeleteServiceRequest.ServiceName)
  return _internal_servicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteServiceRequest::set_servicename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servicename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.DeleteServiceRequest.ServiceName)
}
inline std::string* DeleteServiceRequest::mutable_servicename() {
  std::string* _s = _internal_mutable_servicename();
  // @@protoc_insertion_point(field_mutable:share.DeleteServiceRequest.ServiceName)
  return _s;
}
inline const std::string& DeleteServiceRequest::_internal_servicename() const {
  return _impl_.servicename_.Get();
}
inline void DeleteServiceRequest::_internal_set_servicename(const std::string& value) {
  
  _impl_.servicename_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteServiceRequest::_internal_mutable_servicename() {
  
  return _impl_.servicename_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteServiceRequest::release_servicename() {
  // @@protoc_insertion_point(field_release:share.DeleteServiceRequest.ServiceName)
  return _impl_.servicename_.Release();
}
inline void DeleteServiceRequest::set_allocated_servicename(std::string* servicename) {
  if (servicename != nullptr) {
    
  } else {
    
  }
  _impl_.servicename_.SetAllocated(servicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servicename_.IsDefault()) {
    _impl_.servicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.DeleteServiceRequest.ServiceName)
}

// -------------------------------------------------------------------

// GetServiceResponse

// bytes data = 1;
inline void GetServiceResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& GetServiceResponse::data() const {
  // @@protoc_insertion_point(field_get:share.GetServiceResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.GetServiceResponse.data)
}
inline std::string* GetServiceResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:share.GetServiceResponse.data)
  return _s;
}
inline const std::string& GetServiceResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void GetServiceResponse::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceResponse::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceResponse::release_data() {
  // @@protoc_insertion_point(field_release:share.GetServiceResponse.data)
  return _impl_.data_.Release();
}
inline void GetServiceResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.GetServiceResponse.data)
}

// -------------------------------------------------------------------

// GetNodeRequest

// string NodeName = 1;
inline void GetNodeRequest::clear_nodename() {
  _impl_.nodename_.ClearToEmpty();
}
inline const std::string& GetNodeRequest::nodename() const {
  // @@protoc_insertion_point(field_get:share.GetNodeRequest.NodeName)
  return _internal_nodename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNodeRequest::set_nodename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nodename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.GetNodeRequest.NodeName)
}
inline std::string* GetNodeRequest::mutable_nodename() {
  std::string* _s = _internal_mutable_nodename();
  // @@protoc_insertion_point(field_mutable:share.GetNodeRequest.NodeName)
  return _s;
}
inline const std::string& GetNodeRequest::_internal_nodename() const {
  return _impl_.nodename_.Get();
}
inline void GetNodeRequest::_internal_set_nodename(const std::string& value) {
  
  _impl_.nodename_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNodeRequest::_internal_mutable_nodename() {
  
  return _impl_.nodename_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNodeRequest::release_nodename() {
  // @@protoc_insertion_point(field_release:share.GetNodeRequest.NodeName)
  return _impl_.nodename_.Release();
}
inline void GetNodeRequest::set_allocated_nodename(std::string* nodename) {
  if (nodename != nullptr) {
    
  } else {
    
  }
  _impl_.nodename_.SetAllocated(nodename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nodename_.IsDefault()) {
    _impl_.nodename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.GetNodeRequest.NodeName)
}

// -------------------------------------------------------------------

// GetNodeResponse

// bytes NodeData = 1;
inline void GetNodeResponse::clear_nodedata() {
  _impl_.nodedata_.ClearToEmpty();
}
inline const std::string& GetNodeResponse::nodedata() const {
  // @@protoc_insertion_point(field_get:share.GetNodeResponse.NodeData)
  return _internal_nodedata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNodeResponse::set_nodedata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nodedata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:share.GetNodeResponse.NodeData)
}
inline std::string* GetNodeResponse::mutable_nodedata() {
  std::string* _s = _internal_mutable_nodedata();
  // @@protoc_insertion_point(field_mutable:share.GetNodeResponse.NodeData)
  return _s;
}
inline const std::string& GetNodeResponse::_internal_nodedata() const {
  return _impl_.nodedata_.Get();
}
inline void GetNodeResponse::_internal_set_nodedata(const std::string& value) {
  
  _impl_.nodedata_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNodeResponse::_internal_mutable_nodedata() {
  
  return _impl_.nodedata_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNodeResponse::release_nodedata() {
  // @@protoc_insertion_point(field_release:share.GetNodeResponse.NodeData)
  return _impl_.nodedata_.Release();
}
inline void GetNodeResponse::set_allocated_nodedata(std::string* nodedata) {
  if (nodedata != nullptr) {
    
  } else {
    
  }
  _impl_.nodedata_.SetAllocated(nodedata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nodedata_.IsDefault()) {
    _impl_.nodedata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:share.GetNodeResponse.NodeData)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace share

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_share_2eproto
